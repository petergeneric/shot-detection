package com.peterphi.ffmpegtest.parser;

import org.apache.commons.lang.StringUtils;

import java.io.DataInputStream;
import java.io.IOException;

/**
 * Parser for 8-bit P6 PPM data as generated by FFmpeg (not arbitrary PPM images)
 */
public class FFmpegPPMParser
{
	/**
	 * The field separation character FFmpeg uses
	 */
	private static final int FIELD_SEPARATOR = 0x0A;
	/**
	 * The whitespace character FFmpeg uses between width and height values in the dimension field
	 */
	private static final int WHITESPACE = 0x20;


	public VideoFrame parse(DataInputStream dis) throws IOException
	{
		final String format = readASCII(dis);

		if (!StringUtils.equals(format, "P6"))
			throw new IllegalArgumentException("Unrecognised format: parser only understands PPM P6 but got " + format);

		final int width = readASCIINumber(dis);
		final int height = readASCIINumber(dis);
		final int maxIntensity = readASCIINumber(dis);

		if (maxIntensity != 255)
			throw new IllegalArgumentException("Unrecognised format: parser only understands 8-bit PPM P6 but got max intensity " +
			                                   maxIntensity);

		VideoFrame frame = new VideoFrame(height, width);

		populate(frame, dis);

		return frame;
	}


	public void populate(VideoFrame frame, DataInputStream dis) throws IOException
	{
		final int height = frame.getHeight();
		final int width = frame.getWidth();

		final byte[] framebuffer = new byte[height * width * 3];

		// Read the entire frame into memory
		dis.readFully(framebuffer);

		populate(frame, framebuffer);
	}


	public void populate(final VideoFrame frame, final byte[] buffer) throws IOException
	{
		final int height = frame.getHeight();
		final int width = frame.getWidth();

		int offset = 0;
		for (int x = 0; x < height; x++)
		{
			for (int y = 0; y < width; y++)
			{
				final short red = (short) (buffer[offset] & 0xFF);
				final short green = (short) (buffer[offset + 1] & 0xFF);
				final short blue = (short) (buffer[offset + 2] & 0xFF);

				frame.setRGB(x, y, red, green, blue);

				offset += 3;
			}
		}
	}


	private String readASCII(DataInputStream dis) throws IOException
	{
		final char[] str = new char[5]; // Assume maximum string length

		// Read until a whitespace character is encountered
		int offset = 0;
		while (true)
		{
			final int val = dis.readUnsignedByte();

			if (val == FIELD_SEPARATOR || val == WHITESPACE)
				break;

			// TODO make sure val is in ASCII A-Za-z0-9?

			if (offset == str.length)
				throw new IllegalStateException("Error parsing ASCII: too much data. got as far as '" + new String(str,
				                                                                                                   0,
				                                                                                                   offset) + "'");
			str[offset++] = (char) val;
		}

		return new String(str, 0, offset);
	}


	private int readASCIINumber(DataInputStream dis) throws IOException
	{
		final String str = readASCII(dis);

		return Integer.parseInt(str);
	}
}
